/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import {Sphere, useGLTF, useHelper, useScroll} from "@react-three/drei";
import * as THREE from "three";
import {useLayoutEffect, useRef} from "react";
import gsap from "gsap";
import {useFrame} from "@react-three/fiber";
import {ThreeElements} from "@react-three/fiber/dist/declarations/src/three-types";
import {useControls} from "leva";

export const VIEWPORT_HEIGHT = 2.3;
export const SECTIONS_COUNT = 2;

// @ts-ignore
export function Clocks(props) {
  const controls = useControls('Stand', {
    posX: {
      value: 0,
    },
    posY: {
      value: 0,
    },
    posZ: {
      value: 0,
    },

    rotX: {
      value: 0,
    },
    rotY: {
      value: 0,
    },
    rotZ: {
      value: 0,
    }
  })
  // @ts-ignore
  const {nodes, materials} = useGLTF("./models/clocks.gltf");
  console.log({nodes})

  const groupRef = useRef<ThreeElements["group"]>();
  const standRef = useRef<ThreeElements["group"]>();
  const tlRef = useRef<gsap.core.Timeline>();

  const scroll = useScroll();

  useFrame(() => {
    const seek = scroll.offset * tlRef.current!.duration();
    tlRef.current?.seek(seek);
  });

  // @ts-ignore
  useLayoutEffect(() => {
    const initial = {
      y: VIEWPORT_HEIGHT * (SECTIONS_COUNT - 1),
      duration: 2,
    };
    tlRef.current = gsap.timeline();
    console.log('useLayoutEffect', {
      initial
    })
    // @ts-ignore
    // tlRef.current.to(groupRef.current?.position, initial);

    // tlRef.current.from(groupRef.current?.rotation, {
    //   duration: 2,
    //   y: Math.PI / 2,
    // }, 0);
    //
    // tlRef.current.to(groupRef.current?.scale, {
    //   duration: 2,
    //   x: groupRef.current?.scale.x * 2,
    //   y: groupRef.current?.scale.y * 2,
    // }, 1);
    //
    // // tlRef.current.to(groupRef.current?.rotation, {
    // //   duration: 2,
    // //   y: -Math.PI / 2,
    // // },0);
    //
    // tlRef.current.to(standRef.current?.rotation, {
    //   duration: 2,
    //   x: Math.PI / 4,
    // }, 1);
  }, []);

  useHelper(groupRef, THREE.BoxHelper, 'red');


  return (
    <group {...props} dispose={null} ref={groupRef}>
      <RotationOrigin/>

      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Stand.geometry}
        material={nodes.Stand.material}
        position={[1.65, 0.406, -0.306]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Magnet_1_border.geometry}
        material={nodes.Magnet_1_border.material}
        position={[1.14, 0.591, -0.461]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.156, 0.053, 0.156]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Magnet_1.geometry}
        material={nodes.Magnet_1.material}
        position={[1.14, 0.591, -0.461]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.136, 0.05, 0.136]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Magnet_2_border.geometry}
        material={nodes.Magnet_2_border.material}
        position={[-1.149, 0.591, -0.461]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.156, 0.053, 0.156]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Magnet_2.geometry}
        material={nodes.Magnet_2.material}
        position={[-1.149, 0.591, -0.461]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.136, 0.05, 0.136]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Back_base.geometry}
        material={nodes.Back_base.material}
        position={[0, 0.225, -0.277]}
        rotation={[Math.PI / 2, 0, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Mute_btn_base.geometry}
        material={nodes.Mute_btn_base.material}
        position={[1.719, -0.043, -0.124]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={[0.066, 0.073, 0.073]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Mute_btn_top.geometry}
        material={nodes.Mute_btn_top.material}
        position={[1.741, -0.043, -0.124]}
        rotation={[-Math.PI, 0, -Math.PI / 2]}
        scale={[0.073, 0.073, 0.066]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Button_1.geometry}
        material={nodes.Button_1.material}
        position={[-1.215, -0.651, 0.124]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Button_2.geometry}
        material={nodes.Button_2.material}
        position={[-0.577, -0.651, 0.124]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Button_3.geometry}
        material={nodes.Button_3.material}
        position={[0.03, -0.651, 0.124]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Button_4.geometry}
        material={nodes.Button_4.material}
        position={[0.649, -0.65, 0.126]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Base.geometry}
        material={nodes.Base.material}
        rotation={[Math.PI / 2, 0, 0]}
      />
    </group>
  );
}

function BaseMaterial({}) {
  return <meshStandardMaterial color={"#ffffff"}
                               side={THREE.DoubleSide}
                               roughness={0.5}/>
}

function RotationOrigin() {
  return <Sphere args={[0.05, 16, 16]} position={[0, 0, 0]} material={new THREE.MeshBasicMaterial({color: 'red'})}/>
}

useGLTF.preload("./models/clocks.gltf");
